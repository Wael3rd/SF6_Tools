<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SF6 REPLAY EDITOR // ULTIMATE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@400;600;700&display=swap');

        :root {
            --bg-dark: #0f0518;
            --bg-panel: #1a0b2e; /* SF6 Purple */
            --bg-header: #2d1245;
            --accent-pink: #ff0055;
            --accent-green: #ccff00; /* SF6 Lime */
            --accent-blue: #00aaff;
            --text-main: #ffffff;
            --text-dim: #a090b0;
            --border: #4a2a6a;
            
            /* Input Colors MODIFIED FOR SF6 STYLE */
            --c-lp: #00e5ff; --c-lk: #00e5ff;   /* Electric Blue */
            --c-mp: #ffe600; --c-mk: #ffe600;   /* Soft Yellow */
            --c-hp: #ff3333; --c-hk: #ff3333;   /* Red */
            --c-special: #ccff00;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Teko', 'Impact', sans-serif; /* Police style SF6 */
            background: radial-gradient(circle at center, #1f0d30 0%, #0a0410 100%);
            color: var(--text-main);
            margin: 0; padding: 0;
            display: flex; flex-direction: column; height: 100vh;
            overflow: hidden;
            letter-spacing: 0.5px;
        }

        /* --- SCROLLBAR --- */
        ::-webkit-scrollbar { width: 8px; background: #111; }
        ::-webkit-scrollbar-thumb { background: var(--accent-pink); border-radius: 4px; }

        /* --- UI HELPERS --- */
        .skew-box {
            transform: skewX(-15deg);
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 5px 15px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .skew-content { transform: skewX(15deg); } 
        
        button {
            font-family: 'Teko', sans-serif;
            text-transform: uppercase;
            font-size: 1.1em;
            cursor: pointer;
            border: none;
            transition: 0.2s;
        }

        /* --- HEADER --- */
        .toolbar {
            height: 60px;
            background: linear-gradient(90deg, #2d1245 0%, #150820 100%);
            border-bottom: 3px solid var(--accent-pink);
            display: flex; align-items: center; padding: 0 20px; gap: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h1 {
            font-size: 2em; margin: 0; color: var(--accent-green);
            text-shadow: 0 0 10px rgba(204, 255, 0, 0.4);
            margin-right: 30px; font-weight: 700; font-style: italic;
        }

        .btn-tool {
            background: var(--accent-pink); color: white;
            padding: 5px 20px; font-weight: bold;
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); 
        }
        .btn-tool:hover { background: #ff3377; transform: scale(1.05); }
        .btn-tool.secondary { background: #444; }
        .btn-tool.secondary:hover { background: #666; }

        .file-upload input { display: none; }

        /* --- LAYOUT --- */
        .workspace { display: flex; flex: 1; overflow: hidden; background-image: linear-gradient(#1a0b2e 1px, transparent 1px), linear-gradient(90deg, #1a0b2e 1px, transparent 1px); background-size: 40px 40px; }

        /* --- LEFT: SLOTS --- */
        .sidebar {
            width: 240px; background: rgba(15, 5, 24, 0.95);
            border-right: 2px solid var(--border);
            display: flex; flex-direction: column;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        .slot-header { padding: 15px; font-size: 1.2em; color: var(--accent-blue); text-transform: uppercase; border-bottom: 1px solid var(--border); }
        
        .slot-item {
            padding: 15px 20px; border-bottom: 1px solid #332040; cursor: pointer;
            transition: 0.2s; position: relative; overflow: hidden;
        }
        .slot-item:hover { background: rgba(255, 255, 255, 0.05); padding-left: 25px; }
        .slot-item.active {
            background: linear-gradient(90deg, rgba(255,0,85,0.2) 0%, transparent 100%);
            border-left: 5px solid var(--accent-pink);
        }
        .slot-name { font-size: 1.4em; font-weight: 600; }
        .slot-meta { font-size: 0.9em; color: var(--text-dim); }

        /* --- CENTER: EDITOR --- */
        .center-stage {
            flex: 1; display: flex; flex-direction: column; align-items: center;
            justify-content: center; /* Centre verticalement */
            padding: 30px; overflow-y: auto;
        }

        /* --- VISUALIZER --- */
        #gp-visualizer {
            height: 180px; width: 450px; margin-bottom: 30px;
            filter: drop-shadow(0 0 15px rgba(0,0,0,0.5));
        }

		/* Direction Arrows */
        .arrow-shape { 
            fill: #333333; 
            stroke: #000000; stroke-width: 2.5px; 
            transition: 0.05s; 
        }
        .arrow-active { 
            fill: #eeeeee !important; stroke: #ffffff !important; 
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8)); 
        }
        .neutral-dot { fill: #222; stroke: #000000; stroke-width: 2.5px; opacity: 0.3; }
        .neutral-dot.active { opacity: 1; fill: #888 !important; }

        /* Buttons */
        .btn-bg { fill: #111; stroke: #333; stroke-width: 2px; transition: 0.05s; }
        .btn-blue.btn-active { fill: var(--c-lp) !important; stroke: #fff; filter: drop-shadow(0 0 8px var(--c-lp)); }
        .btn-yellow.btn-active { fill: var(--c-mp) !important; stroke: #fff; filter: drop-shadow(0 0 8px var(--c-mp)); }
        .btn-red.btn-active { fill: var(--c-hp) !important; stroke: #fff; filter: drop-shadow(0 0 8px var(--c-hp)); }
        .stick-label { fill: #666; font-size: 10px; font-family: sans-serif; text-anchor: middle; font-weight: bold; pointer-events: none; }
        .btn-active + .stick-label { fill: #000; } 

        /* CONTROLS */
        .editor-controls {
            width: 100%; max-width: 600px;
            background: rgba(30, 15, 50, 0.8);
            border: 1px solid var(--border);
            padding: 25px;
            position: relative;
        }
        .editor-controls::before { content:''; position: absolute; top:-1px; left:-1px; width: 20px; height: 20px; border-top: 2px solid var(--accent-green); border-left: 2px solid var(--accent-green); }
        .editor-controls::after { content:''; position: absolute; bottom:-1px; right:-1px; width: 20px; height: 20px; border-bottom: 2px solid var(--accent-green); border-right: 2px solid var(--accent-green); }

        .edit-row { display: flex; gap: 15px; align-items: center; margin-bottom: 20px; }
        .big-input {
            background: #000; border: 1px solid #555; color: var(--accent-green);
            font-size: 1.8em; padding: 10px; text-align: center; font-family: 'Teko', monospace;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            transition: 0.2s;
        }
        .big-input:focus { border-color: var(--accent-green); outline: none; box-shadow: 0 0 15px rgba(204,255,0,0.2); }
        
        /* NAVIGATION HIGHLIGHT */
        .nav-selected {
            border: 2px solid var(--accent-blue) !important;
            box-shadow: 0 0 15px var(--accent-blue) !important;
            transform: scale(1.02);
            z-index: 10;
        }
        .nav-wrapper {
            border: 1px solid transparent; padding: 5px; border-radius: 5px; transition: 0.2s;
        }
        
        .rec-panel { padding: 5px; border-radius: 5px; }

        .btn-rec {
            width: 100%; padding: 15px; font-size: 1.5em; letter-spacing: 2px;
            background: #222; border: 1px solid #555; color: #fff;
            clip-path: polygon(5% 0, 100% 0, 95% 100%, 0% 100%);
        }
        .btn-rec:hover { background: #333; }
        .btn-rec.waiting { background: #dba100; color: #000; animation: glow 1s infinite alternate; }
        .btn-rec.active { background: #ff0000; color: #fff; box-shadow: 0 0 20px red; }
        
        /* BUTTONS ACTIONS */
        .btn-col { display: flex; flex-direction: column; gap: 5px; }
        .btn-small-action {
            background: #444; color: white; border: 1px solid #666;
            padding: 2px 20px; font-size: 1em; height: 32px;
            font-family: 'Teko'; text-transform: uppercase; cursor: pointer;
        }
        .btn-small-action:hover { background: #555; border-color:white; }
        .btn-insert { border-bottom: 2px solid var(--accent-blue); }
        .btn-del { border-bottom: 2px solid var(--accent-pink); color:#faa; }

        @keyframes glow { from { opacity: 0.8; } to { opacity: 1; box-shadow: 0 0 15px #dba100; } }

        /* FEEDBACK ANIMATIONS */
        @keyframes flashGreen {
            0% { background-color: rgba(204, 255, 0, 0.5); }
            100% { background-color: transparent; }
        }
        @keyframes flashRed {
            0% { background-color: rgba(255, 0, 85, 0.5); }
            100% { background-color: transparent; }
        }
        .flash-insert { animation: flashGreen 0.5s ease-out; }
        .flash-delete { animation: flashRed 0.5s ease-out; }

        /* --- RIGHT: HISTORY --- */
        .timeline-panel {
            width: 380px; background: rgba(20, 10, 30, 0.95);
            border-left: 2px solid var(--border); display: flex; flex-direction: column;
        }
        .timeline-header {
            padding: 15px; background: #251035; color: var(--accent-green); font-size: 1.2em; text-align: center; letter-spacing: 2px; font-weight: bold; border-bottom: 1px solid var(--border);
        }
        .timeline-list { flex: 1; overflow-y: auto; padding: 0; scroll-behavior: smooth; }
        
        .timeline-step {
            display: flex; align-items: center; gap: 10px; padding: 8px 15px;
            border-bottom: 1px solid #332040; cursor: pointer; transition: 0.1s;
            font-family: 'Roboto Mono', monospace; 
        }
        .timeline-step:hover { background: rgba(255,255,255,0.1); }
        .timeline-step.selected {
            background: linear-gradient(90deg, rgba(0,170,255,0.2) 0%, transparent 100%);
            border-left: 4px solid var(--accent-blue);
        }
        
        .step-frames { color: #666; width: 40px; text-align: right; font-weight: bold; }
        
        /* --- TIMELINE MINI VISUALS --- */
        .t-btn {
            width: 22px; height: 22px; border-radius: 50%;
            display: inline-flex; align-items: center; justify-content: center;
            font-size: 10px; font-weight: bold; font-family: sans-serif;
            background: #111; border: 2px solid #333; color: #666;
            margin-right: 4px;
        }
        .t-btn.active-lp, .t-btn.active-lk { background: var(--c-lp); border-color: white; color: black; box-shadow: 0 0 5px var(--c-lp); }
        .t-btn.active-mp, .t-btn.active-mk { background: var(--c-mp); border-color: white; color: black; box-shadow: 0 0 5px var(--c-mp); }
        .t-btn.active-hp, .t-btn.active-hk { background: var(--c-hp); border-color: white; color: black; box-shadow: 0 0 5px var(--c-hp); }
        
        .t-arrow {
            font-size: 1.4em; font-weight: bold; color: #333; margin-right: 5px; width: 20px; text-align: center;
            text-shadow: none;
        }
        .t-arrow.active { color: #eee; text-shadow: 0 0 5px white; }

        /* --- MODAL CONFIG --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            z-index: 1000; display: none; justify-content: center; align-items: center;
        }
        .modal-overlay.open { display: flex; }
        
        .modal-box {
            background: #1a0b2e; border: 2px solid var(--accent-pink);
            width: 50%; height: 90vh; 
            box-shadow: 0 0 30px rgba(255,0,85,0.4);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal-header {
            background: var(--accent-pink); color: white; padding: 15px;
            font-size: 1.5em; font-weight: bold; text-align: center;
            flex-shrink: 0;
            position: relative;
        }
        .modal-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }
        .modal-close:hover {
            color: var(--accent-green);
            transform: translateY(-50%) scale(1.2);
        }
        
        /* TABS */
        .modal-tabs {
            display: flex;
            background: #150820;
            border-bottom: 2px solid var(--border);
            flex-shrink: 0;
        }
        .modal-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: 0.2s;
            color: #666;
        }
        .modal-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #999;
        }
        .modal-tab.active {
            color: var(--accent-green);
            border-bottom-color: var(--accent-green);
            background: rgba(204, 255, 0, 0.1);
        }
        
        /* NAVIGATION SHORTCUTS PAGE */
        .shortcuts-page {
            display: none;
            padding: 20px;
            flex: 1;
            overflow: hidden;
        }
        .shortcuts-page.active {
            display: flex;
            flex-direction: column;
        }
        .shortcuts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            flex: 1;
        }
        .shortcut-card {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            padding: 12px;
            border-left: 3px solid var(--accent-blue);
        }
        .shortcut-title {
            font-size: 1em;
            color: var(--accent-green);
            font-weight: bold;
            margin-bottom: 8px;
        }
        .shortcut-keys {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        .shortcut-key {
            background: #000;
            border: 1px solid #555;
            padding: 4px 10px;
            font-size: 0.85em;
            font-family: monospace;
            border-radius: 3px;
            color: var(--accent-blue);
        }
        .shortcut-desc {
            font-size: 0.85em;
            color: #999;
            line-height: 1.3;
        }

        .socd-section { 
            padding: 20px 20px 0 20px; 
            border-bottom: 1px solid #444; 
            flex-shrink: 0;
        }
        .socd-select { width:100%; padding:10px; background:#000; color:#fff; border:1px solid #555; font-family:'Teko'; font-size:1.2em; }

        .config-page {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        .config-page:not(.active) {
            display: none;
        }
        .config-page.active {
            display: flex;
        }
        
        .config-list { 
            padding: 20px; 
            flex: 1; 
            overflow-y: auto;
        }
        .config-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; border-bottom: 1px solid #444;
            transition: 0.2s;
        }
        .config-row.selected {
            background: linear-gradient(90deg, rgba(0,170,255,0.3) 0%, transparent 100%);
            border-left: 4px solid var(--accent-blue);
            padding-left: 16px;
        }
        .config-label { font-size: 1.2em; color: var(--accent-blue); }
        .btn-bind {
            background: #000; border: 1px solid #555; color: #fff; padding: 5px 15px;
            font-family: monospace; width: 140px; text-align: center;
        }
        .btn-bind.listening { background: var(--accent-green); color: black; border-color: white; }

    </style>
</head>
<body>

    <div class="toolbar">
        <h1>SF6 EDITOR <span style="font-size:0.5em; color:white; font-style:normal;">// ULTIMATE</span></h1>
        
        <div class="file-upload">
            <label class="btn-tool secondary skew-box">
                <span class="skew-content">üìÇ LOAD</span>
                <input type="file" id="fileInput" accept=".json">
            </label>
        </div>

        <button onclick="createNew()" class="btn-tool secondary skew-box"><span class="skew-content">üìÑ NEW</span></button>
        <button onclick="saveJson()" class="btn-tool skew-box"><span class="skew-content">üíæ SAVE JSON</span></button>
        
        <span style="flex:1;"></span>
        <button onclick="openConfigModal()" id="config-btn" class="btn-tool secondary skew-box" style="border: 1px solid var(--accent-blue); background:#112; position:relative; overflow:hidden;">
            <div id="config-progress" style="position:absolute; left:0; top:0; height:100%; width:0%; background:var(--accent-green); transition:width 0.05s linear, background 0.1s;"></div>
            <span class="skew-content" style="color:var(--accent-blue); position:relative; z-index:1;">‚öô CONFIG</span>
        </button>
        <span id="current-file-name" style="color:#666; font-size:0.8em; margin-left: 10px;">Data.json</span>
    </div>

    <div class="workspace">
        
        <aside class="sidebar" id="slot-list">
            <div class="slot-header">Replay Slots</div>
            </aside>

        <main class="center-stage">

            <svg id="gp-visualizer" viewBox="0 0 320 140">
                <g transform="translate(60, 70)">
                    <circle id="arrow-5" cx="0" cy="0" r="10" class="neutral-dot" />
                    <defs>
                        <path id="arrow-shape-def" d="M 0,-52 L -11.5,-36 L -5.5,-36 L -5.5,-25 L 5.5,-25 L 5.5,-36 L 11.5,-36 Z" />
                    </defs>
                    <use xlink:href="#arrow-shape-def" id="arrow-8" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-9" transform="rotate(45)" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-6" transform="rotate(90)" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-3" transform="rotate(135)" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-2" transform="rotate(180)" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-1" transform="rotate(225)" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-4" transform="rotate(270)" class="arrow-shape" />
                    <use xlink:href="#arrow-shape-def" id="arrow-7" transform="rotate(315)" class="arrow-shape" />
                </g>

                <g transform="translate(155, 48)">
                    <g transform="translate(0, 0)">
                        <circle id="vis-btn-lp" cx="0" cy="0" r="16" class="btn-bg btn-blue" />
                        <text x="0" y="4" class="stick-label">LP</text>
                    </g>
                    <g transform="translate(45, 0)">
                        <circle id="vis-btn-mp" cx="0" cy="0" r="16" class="btn-bg btn-yellow" />
                        <text x="0" y="4" class="stick-label">MP</text>
                    </g>
                    <g transform="translate(90, 0)">
                        <circle id="vis-btn-hp" cx="0" cy="0" r="16" class="btn-bg btn-red" />
                        <text x="0" y="4" class="stick-label">HP</text>
                    </g>

                    <g transform="translate(0, 45)">
                        <circle id="vis-btn-lk" cx="0" cy="0" r="16" class="btn-bg btn-blue" />
                        <text x="0" y="4" class="stick-label">LK</text>
                    </g>
                    <g transform="translate(45, 45)">
                        <circle id="vis-btn-mk" cx="0" cy="0" r="16" class="btn-bg btn-yellow" />
                        <text x="0" y="4" class="stick-label">MK</text>
                    </g>
                    <g transform="translate(90, 45)">
                        <circle id="vis-btn-hk" cx="0" cy="0" r="16" class="btn-bg btn-red" />
                        <text x="0" y="4" class="stick-label">HK</text>
                    </g>
                </g>
            </svg>
            <div class="editor-controls">
                <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                    <label style="color:var(--accent-blue); font-weight:bold;">DURATION (FRAMES)</label>
                    <label style="color:var(--accent-blue); font-weight:bold;">INPUT ACTION</label>
                </div>
                
                <div class="edit-row">
                    <input type="number" id="edit-frames" class="big-input" style="width:100px;" value="1" min="1">
                    <input type="text" id="edit-action" class="big-input" style="flex:1; text-align:left;" value="5" placeholder="Waiting...">
                    
                    <div class="btn-col">
                        <button id="btn-insert" onclick="insertStep()" class="btn-small-action btn-insert" title="Insert Step">INSERT</button>
                        <button id="btn-del" onclick="deleteStep()" class="btn-small-action btn-del" title="Delete Step (Select)">DEL</button>
                    </div>
                </div>

                <div class="rec-panel" id="rec-panel">
                    <button id="btn-record-main" class="btn-rec" onclick="toggleRecording()">‚è∫ RECORD SLOT</button>
                </div>
                
                <div style="display:flex; gap:20px; margin-top:20px; padding-top:15px; border-top:1px solid #444;">
                    <label id="chk-label" class="nav-wrapper" style="display:flex; align-items:center; cursor:pointer;">
                        <input type="checkbox" id="chk-slot-active" onchange="toggleSlotActive(this.checked)" style="transform:scale(1.5); margin-right:10px;"> 
                        <span style="color:var(--accent-green); font-weight:bold;">SLOT ENABLED</span>
                    </label>
                    <label style="margin-left:auto; color:#ccc;">
                        Weight: <input type="number" id="inp-weight" value="1" style="width:50px; background:#000; color:white; border:1px solid #555; padding:5px; text-align:center;">
                    </label>
                </div>
            </div>

        </main>

        <aside class="timeline-panel">
            <div class="timeline-header">COMMAND HISTORY</div>
            <div class="timeline-list" id="timeline-container">
                </div>
            </aside>

    </div>

    <div class="modal-overlay" id="config-modal">
        <div class="modal-box">
            <div class="modal-header">
                CONTROLLER CONFIGURATION
                <button class="modal-close" onclick="closeConfigModal()">‚úï</button>
            </div>
            
            <div class="modal-tabs">
                <div class="modal-tab active" onclick="switchConfigTab('buttons')">BUTTONS CONFIG</div>
                <div class="modal-tab" onclick="switchConfigTab('shortcuts')">NAVIGATION SHORTCUTS</div>
            </div>
            
            <!-- BUTTONS CONFIG PAGE -->
            <div id="buttons-config-page" class="config-page active">
                <div class="socd-section">
                    <label style="color:var(--accent-green); font-size:1.2em; display:block; margin-bottom:10px;">SOCD CLEANING MODE</label>
                    <select id="socd-select" onchange="changeSOCD(this.value)" class="socd-select">
                        <option value="NEUTRAL">NEUTRAL (CPT Standard)</option>
                        <option value="UP_PRIO">UP PRIORITY (Classic Hitbox)</option>
                        <option value="LAST_WIN">LAST INPUT WINS (Keyboard)</option>
                    </select>
                    <p style="color:#666; font-size:0.9em; margin-top:5px;">
                        Behavior when pressing Opposite Directions (Left+Right or Up+Down).
                    </p>
                </div>

                <div id="config-list" class="config-list">
                </div>
                <div style="padding:15px; text-align:center; color: var(--accent-green); font-size: 1.3em; font-weight: bold;">
                    PRESS START TO CLOSE
                </div>
            </div>
            
            <!-- NAVIGATION SHORTCUTS PAGE -->
            <div id="shortcuts-page" class="shortcuts-page">
                <div class="shortcuts-grid">
                    <div class="shortcut-card">
                        <div class="shortcut-title">NAVIGATE SLOTS</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">L1</span>
                            <span class="shortcut-key">R1</span>
                        </div>
                        <div class="shortcut-desc">Switch between replay slots</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">NAVIGATE TIMELINE</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">L2</span>
                            <span class="shortcut-key">R2</span>
                        </div>
                        <div class="shortcut-desc">Move through command history (hold to scroll)</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">NAVIGATE FIELDS</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">D-PAD</span>
                            <span class="shortcut-key">L-STICK</span>
                        </div>
                        <div class="shortcut-desc">Move between UI elements</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">INSERT STEP</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">START</span>
                        </div>
                        <div class="shortcut-desc">When "Insert" button is selected</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">DELETE STEP</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">SELECT</span>
                        </div>
                        <div class="shortcut-desc">When "Del" button is selected</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">TOGGLE RECORDING</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">START</span>
                        </div>
                        <div class="shortcut-desc">When "Record" panel is selected</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">STOP RECORDING</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">START</span>
                        </div>
                        <div class="shortcut-desc">During active recording</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">OPEN CONFIG MENU</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">HOLD START</span>
                        </div>
                        <div class="shortcut-desc">Hold for 0.5 seconds</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">CLOSE CONFIG MENU</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">START</span>
                            <span class="shortcut-key">ESC</span>
                        </div>
                        <div class="shortcut-desc">Exit configuration</div>
                    </div>
                    
                    <div class="shortcut-card">
                        <div class="shortcut-title">CONFIG NAVIGATION</div>
                        <div class="shortcut-keys">
                            <span class="shortcut-key">D-PAD</span>
                            <span class="shortcut-key">L-STICK</span>
                        </div>
                        <div class="shortcut-desc">Navigate button assignments (hold to scroll)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div style="position:fixed; bottom:10px; left:10px; color:#555; font-size:0.8em;">
        <span id="gp-led" style="display:inline-block; width:10px; height:10px; background:#333; border-radius:50%; margin-right:5px;"></span>
        <span id="gp-text">Waiting for Gamepad...</span>
    </div>

    <script>
        // --- DATA ---
        let currentData = [];
        let activeSlotIndex = 0;
        let selectedLineIndex = -1;
        let currentFileName = "SF6_Replay_Data.json";
        
        // --- CONFIG ---
        const SF6_ACTIONS = [
            "LP", "MP", "HP", "PPP",
            "LK", "MK", "HK", "KKK",
            "DI", "Parry", "Throw"
        ];
        
        let btnMap = {
            0: "LK", 1: "MK", 2: "LP", 3: "MP",
            4: "LB", 5: "HP", 6: "LT", 7: "HK",
            8: "Select", 9: "Start"
        };

        // PRIORITY SORT ORDER (Without L3/R3)
        const SORT_ORDER = ['LP', 'LK', 'MP', 'MK', 'HP', 'HK'];
        
        // MACRO EXPANSION
        const MACRO_EXPANSION = {
            "DI": ["HP", "HK"], "Parry": ["MP", "MK"], "Throw": ["LP", "LK"],
            "PPP": ["LP", "MP", "HP"], "KKK": ["LK", "MK", "HK"],
            "LB": ["HP", "HK"], "LT": ["MP", "MK"]
        };

        // SOCD VARS
        let socdMode = "NEUTRAL"; 
        let lastInputState = { l: false, r: false, u: false, d: false };
        let lastWinHorz = null;
        let lastWinVert = null;

        // NAVIGATION STATE
        // Grid:
        // 0:Frames  1:Action  2:Insert
        //                     6:Del
        // 3:Record
        // 4:Slot    5:Weight
        let navIndex = 0; 
        let navCooldown = 0;
        const NAV_IDS = ['edit-frames', 'edit-action', 'btn-insert', 'rec-panel', 'chk-label', 'inp-weight', 'btn-del'];
        
        // SMART BACKTRACK MEMORY
        let prevNavIndex = -1; // Tracks IMMEDIATE previous position for smart return

        // AUTO SCROLL REPEAT VARS
        let l1HoldTimer = 0;
        let l2HoldTimer = 0;
        let r1HoldTimer = 0;
        let r2HoldTimer = 0;
        const NAV_REPEAT_DELAY = 20; 
        const NAV_REPEAT_RATE = 4;

        let remapState = { active: false, action: null };
        let recordingState = { active: false, waiting: false, lastInput: null };
        let lastFrameTime = 0;
        const FPS = 60;
        const FRAME_INTERVAL = 1000 / FPS;

        // CONFIG MENU NAVIGATION
        let configMenuIndex = 0;
        let configMenuOpen = false;
        let configNavCooldown = 0; // Cooldown pour ralentir la navigation
        let ignoreNextStartRelease = false; // Pour √©viter la fermeture imm√©diate du menu
        let currentConfigTab = 'buttons'; // 'buttons' ou 'shortcuts'
        
        // START BUTTON HOLD TIMER (for opening config menu)
        let startHoldFrames = 0;
        const START_HOLD_THRESHOLD = 30; // 0.5 secondes √† 60fps (2 fois plus court qu'avant)

        let isInputFocused = false;
        let lastButtons = new Array(20).fill(false);
        let lastAxes = new Array(4).fill(0); // Pour tracker l'√©tat pr√©c√©dent des axes du stick
        let lastDirection = 5;

        const DIR_ARROWS = { 1: "‚Üô", 2: "‚¨á", 3: "‚Üò", 4: "‚¨Ö", 6: "‚û°", 7: "‚Üñ", 8: "‚¨Ü", 9: "‚Üó", 5: "‚Ä¢" };

        // --- INIT ---
        function init() {
            loadConfig();
            createNew();
            setupEventListeners();
            requestAnimationFrame(loop);
            updateNavVisuals();
        }

        function createNew() {
            currentData = Array.from({length: 8}, (_, i) => ({ 
                id: i + 1, empty: i !== 0, weight: 1, timeline: [] 
            }));
            activeSlotIndex = 0; selectedLineIndex = -1; renderAll();
        }

        function loadConfig() {
            const stored = localStorage.getItem('sf6_ult_map');
            if (stored) { try { btnMap = JSON.parse(stored); } catch(e){} }
            const storedSocd = localStorage.getItem('sf6_ult_socd');
            if (storedSocd) { socdMode = storedSocd; document.getElementById('socd-select').value = socdMode; }
        }
        function saveConfig() { localStorage.setItem('sf6_ult_map', JSON.stringify(btnMap)); }
        function changeSOCD(val) { socdMode = val; localStorage.setItem('sf6_ult_socd', val); }

        function openConfigModal() { 
            configMenuOpen = true;
            configMenuIndex = 0;
            currentConfigTab = 'buttons';
            ignoreNextStartRelease = true; // Ignorer le premier release apr√®s l'ouverture
            renderConfigList(); 
            document.getElementById('config-modal').classList.add('open'); 
        }
        function closeConfigModal() { 
            remapState.active = false; 
            configMenuOpen = false;
            startHoldFrames = 0; // Reset le timer pour √©viter double trigger
            ignoreNextStartRelease = false; // Reset le flag
            document.getElementById('config-modal').classList.remove('open');
            // Restaurer le texte du status
            const txt = document.getElementById('gp-text');
            txt.textContent = "CONTROLLER CONNECTED (60Hz)";
            txt.style.color = "";
        }
        
        function switchConfigTab(tab) {
            currentConfigTab = tab;
            
            // Update tabs UI
            document.querySelectorAll('.modal-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.config-page, .shortcuts-page').forEach(p => p.classList.remove('active'));
            
            if (tab === 'buttons') {
                document.querySelector('.modal-tab:nth-child(1)').classList.add('active');
                document.getElementById('buttons-config-page').classList.add('active');
            } else {
                document.querySelector('.modal-tab:nth-child(2)').classList.add('active');
                document.getElementById('shortcuts-page').classList.add('active');
            }
        }

        function renderConfigList() {
            const container = document.getElementById('config-list');
            container.innerHTML = '';
            SF6_ACTIONS.forEach((action, index) => {
                let currentId = Object.keys(btnMap).find(key => btnMap[key] === action);
                let displayVal = currentId !== undefined ? `BUTTON ${currentId}` : "---";
                const row = document.createElement('div');
                row.className = 'config-row';
                if (index === configMenuIndex) {
                    row.classList.add('selected');
                }
                row.innerHTML = `<span class="config-label">${action}</span><button class="btn-bind">${displayVal}</button>`;
                container.appendChild(row);
            });
        }

        // NOUVELLE FONCTION : Scroll automatique vers l'√©l√©ment s√©lectionn√©
        function scrollConfigToSelected() {
            const container = document.getElementById('config-list');
            const selected = container.querySelector('.config-row.selected');
            if (selected) {
                selected.scrollIntoView({ behavior: 'auto', block: 'center' });
            }
        }

        function handleConfigMenuNavigation(gp) {
            // Cooldown pour √©viter la navigation trop rapide
            if (configNavCooldown > 0) {
                configNavCooldown--;
                return;
            }
            
            // Navigation GAUCHE/DROITE pour changer de TAB
            const leftDpad = gp.buttons[14]?.pressed;
            const rightDpad = gp.buttons[15]?.pressed;
            const leftStick = gp.axes[0] < -0.6;
            const rightStick = gp.axes[0] > 0.6;
            
            const leftEdge = (leftDpad && !lastButtons[14]) || (leftStick && !(lastAxes[0] < -0.6));
            const rightEdge = (rightDpad && !lastButtons[15]) || (rightStick && !(lastAxes[0] > 0.6));
            
            if (leftEdge) {
                switchConfigTab(currentConfigTab === 'buttons' ? 'shortcuts' : 'buttons');
                configNavCooldown = 8;
                return;
            }
            if (rightEdge) {
                switchConfigTab(currentConfigTab === 'buttons' ? 'shortcuts' : 'buttons');
                configNavCooldown = 8;
                return;
            }
            
            // Le reste du code ne s'applique QUE sur la page BUTTONS CONFIG
            if (currentConfigTab !== 'buttons') return;
            
            // Navigation haut/bas avec DPAD ET stick gauche
            const upDpad = gp.buttons[12]?.pressed;
            const downDpad = gp.buttons[13]?.pressed;
            const upStick = gp.axes[1] < -0.6; // Seuil plus √©lev√© pour le stick
            const downStick = gp.axes[1] > 0.6;
            
            // D√©tecter un changement d'√©tat (edge detection)
            const upDpadEdge = upDpad && !lastButtons[12];
            const downDpadEdge = downDpad && !lastButtons[13];
            const upStickEdge = upStick && !(lastAxes[1] < -0.6);
            const downStickEdge = downStick && !(lastAxes[1] > 0.6);
            
            // NOUVELLE LOGIQUE : Auto-scroll si maintenu (hold)
            // Compteurs pour le hold
            if (!window.configUpHoldTimer) window.configUpHoldTimer = 0;
            if (!window.configDownHoldTimer) window.configDownHoldTimer = 0;
            
            if (upDpad || upStick) {
                window.configUpHoldTimer++;
                if (upDpadEdge || upStickEdge || (window.configUpHoldTimer > NAV_REPEAT_DELAY && window.configUpHoldTimer % NAV_REPEAT_RATE === 0)) {
                    configMenuIndex--;
                    if (configMenuIndex < 0) configMenuIndex = SF6_ACTIONS.length - 1;
                    renderConfigList();
                    scrollConfigToSelected(); // NOUVEAU : Scroll automatique
                    if (upDpadEdge || upStickEdge) {
                        configNavCooldown = 8; // Cooldown seulement pour le premier input
                    }
                }
            } else {
                window.configUpHoldTimer = 0;
            }
            
            if (downDpad || downStick) {
                window.configDownHoldTimer++;
                if (downDpadEdge || downStickEdge || (window.configDownHoldTimer > NAV_REPEAT_DELAY && window.configDownHoldTimer % NAV_REPEAT_RATE === 0)) {
                    configMenuIndex++;
                    if (configMenuIndex >= SF6_ACTIONS.length) configMenuIndex = 0;
                    renderConfigList();
                    scrollConfigToSelected(); // NOUVEAU : Scroll automatique
                    if (downDpadEdge || downStickEdge) {
                        configNavCooldown = 8; // Cooldown seulement pour le premier input
                    }
                }
            } else {
                window.configDownHoldTimer = 0;
            }
            
            // NOUVELLE LOGIQUE : Assignation directe sans mode "listening"
            // Trouver START et SELECT pour les ignorer
            const startBtnKey = Object.keys(btnMap).find(k => btnMap[k] === "Start");
            const selectBtnKey = Object.keys(btnMap).find(k => btnMap[k] === "Select");
            
            // D√®s qu'on appuie sur un bouton action (pas directionnel, ni START, ni SELECT)
            gp.buttons.forEach((b, i) => {
                if (i >= 12 && i <= 15) return; // Ignore les directionnelles
                if (i.toString() === startBtnKey || i.toString() === selectBtnKey) return; // Ignore START et SELECT
                
                if (b.pressed && !lastButtons[i]) {
                    const action = SF6_ACTIONS[configMenuIndex];
                    // Enlever l'ancien mapping de cette action
                    Object.keys(btnMap).forEach(k => { 
                        if(btnMap[k] === action) delete btnMap[k]; 
                    });
                    // Assigner le nouveau bouton directement
                    btnMap[i] = action;
                    saveConfig();
                    setTimeout(() => renderConfigList(), 100);
                }
            });
        }

        // --- SORT HELPER ---
        function sortButtons(btnArray) {
            return btnArray.sort((a, b) => {
                let ia = SORT_ORDER.indexOf(a); let ib = SORT_ORDER.indexOf(b);
                if (ia === -1) ia = 99; if (ib === -1) ib = 99;
                return ia - ib;
            });
        }

        // --- RENDER UI ---
        function renderAll() {
            renderSidebar();
            renderTimeline();
            updateEditorFields();
        }

        function renderSidebar() {
            const container = document.getElementById('slot-list');
            container.innerHTML = '<div class="slot-header">REPLAY SLOTS</div>';
            currentData.forEach((slot, idx) => {
                const div = document.createElement('div');
                div.className = `slot-item ${idx === activeSlotIndex ? 'active' : ''}`;
                div.onclick = () => selectSlot(idx);
                let status = slot.empty ? '<span style="color:#555">DISABLED</span>' : '<span style="color:var(--accent-green)">ACTIVE</span>';
                div.innerHTML = `<div class="slot-name">SLOT ${idx + 1}</div><div class="slot-meta">${slot.timeline.length} Steps ‚Ä¢ ${status}</div>`;
                container.appendChild(div);
            });
        }

        function renderTimeline(flashType = null) {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';
            const timeline = currentData[activeSlotIndex].timeline;
            if (timeline.length === 0) {
                container.innerHTML = '<div style="padding:20px; text-align:center; color:#555;">NO DATA</div>';
                return;
            }
            timeline.forEach((line, idx) => {
                const parts = line.split(':');
                const frames = parts[0].replace('f','').trim();
                const action = parts[1] ? parts[1].trim() : "5";
                const el = document.createElement('div');
                el.className = `timeline-step ${idx === selectedLineIndex ? 'selected' : ''}`;
                
                if (flashType && idx === selectedLineIndex) {
                    if (flashType === 'insert') el.classList.add('flash-insert');
                    if (flashType === 'delete') el.classList.add('flash-delete');
                }

                el.onclick = () => selectLine(idx);
                el.innerHTML = `<div class="step-frames">${frames}</div><div style="flex:1; display:flex; flex-wrap:wrap; margin-left:10px;">${generateTimelineVisuals(action)}</div>`;
                container.appendChild(el);
            });
            
            if (selectedLineIndex !== -1) {
                const selectedEl = container.children[selectedLineIndex];
                if (selectedEl) { selectedEl.scrollIntoView({ behavior: 'auto', block: 'center' }); }
            }
        }

        function generateTimelineVisuals(actionStr) {
            let html = "";
            let rawParts = actionStr.split('+');
            let dir = 5;
            let btns = [];

            rawParts.forEach(p => {
                p = p.trim(); if(!p) return;
                if(p.length === 1 && !isNaN(p)) { dir = p; } 
                else if (p === "Start" || p === "Select") { return; }
                else if (MACRO_EXPANSION[p]) { btns.push(...MACRO_EXPANSION[p]); }
                else { btns.push(p); }
            });

            btns = [...new Set(btns)];
            btns = sortButtons(btns);

            let arrowClass = (dir !== "5") ? "t-arrow active" : "t-arrow";
            let arrowTxt = DIR_ARROWS[dir] || "‚Ä¢";
            html += `<span class="${arrowClass}">${arrowTxt}</span>`;

            btns.forEach(b => {
                let cls = "t-btn";
                if(b === "LP") cls += " active-lp"; else if(b === "MP") cls += " active-mp"; else if(b === "HP") cls += " active-hp";
                else if(b === "LK") cls += " active-lk"; else if(b === "MK") cls += " active-mk"; else if(b === "HK") cls += " active-hk";
                html += `<span class="${cls}">${b}</span>`;
            });
            return html;
        }

        function generateVisuals(actionStr) { return generateTimelineVisuals(actionStr); }

        function updateEditorFields() {
            document.getElementById('chk-slot-active').checked = !currentData[activeSlotIndex].empty;
            document.getElementById('inp-weight').value = currentData[activeSlotIndex].weight;
            const timeline = currentData[activeSlotIndex].timeline;
            if (selectedLineIndex >= 0 && selectedLineIndex < timeline.length) {
                const parts = timeline[selectedLineIndex].split(':');
                document.getElementById('edit-frames').value = parts[0].replace('f','').trim();
                document.getElementById('edit-action').value = parts[1] ? parts[1].trim() : "5";
                // NE PAS visualiser l'action lors de la navigation dans l'historique
                // visualizeAction(parts[1] ? parts[1].trim() : "5");
            } else {
                // Seulement r√©initialiser si pas en enregistrement et pas en focus
                if(!recordingState.active && !isInputFocused) {
                    document.getElementById('edit-frames').value = "1";
                    document.getElementById('edit-action').value = "5";
                }
            }
        }

        function selectSlot(idx) {
            if (recordingState.active) stopRecording();
            activeSlotIndex = idx;
            const len = currentData[idx].timeline.length;
            selectedLineIndex = len > 0 ? len - 1 : -1;
            renderAll();
            const sb = document.getElementById('slot-list');
            const el = sb.children[idx + 1]; 
            if(el) el.scrollIntoView({block: 'nearest'});
        }
        function selectLine(idx) { selectedLineIndex = idx; renderTimeline(); updateEditorFields(); }
        function toggleSlotActive(active) { currentData[activeSlotIndex].empty = !active; renderSidebar(); }

        // --- NAVIGATION LOGIC (SMART BACK-TRACK) ---
        function updateNavVisuals() {
            NAV_IDS.forEach(id => document.getElementById(id).classList.remove('nav-selected'));
            if (!isInputFocused && !recordingState.active) {
                document.getElementById(NAV_IDS[navIndex]).classList.add('nav-selected');
            }
        }

        function handleNavigation(gp) {
            if(navCooldown > 0) { navCooldown--; return; }

            let x = gp.axes[0]; let y = gp.axes[1];
            if(gp.buttons[12]?.pressed) y = -1; if(gp.buttons[13]?.pressed) y = 1;
            if(gp.buttons[14]?.pressed) x = -1; if(gp.buttons[15]?.pressed) x = 1;
            
            let moved = false;
            let current = navIndex;

            if (Math.abs(x) > 0.5) {
                if (x > 0) { // RIGHT
                    if(current === 0) navIndex = 1; 
                    else if(current === 1) { navIndex = (prevNavIndex === 6) ? 6 : 2; } // Smart return to 6 or default 2
                    else if(current === 4) navIndex = 5;
                } else { // LEFT
                    if(current === 2) navIndex = 1;
                    else if(current === 6) navIndex = 1;
                    else if(current === 1) navIndex = 0; 
                    else if(current === 5) navIndex = 4;
                }
                moved = true;
            } else if (Math.abs(y) > 0.5) {
                if (y > 0) { // DOWN
                    if(current === 0 || current === 1) navIndex = 3;
                    else if(current === 2) navIndex = 6; 
                    else if(current === 6) navIndex = 3; 
                    else if(current === 3) { navIndex = (prevNavIndex === 5) ? 5 : 4; } // Smart return to 5 or default 4
                } else { // UP
                    if(current === 4 || current === 5) navIndex = 3; 
                    else if(current === 3) { 
                        if(prevNavIndex === 0) navIndex = 0;
                        else if(prevNavIndex === 2) navIndex = 2;
                        else if(prevNavIndex === 6) navIndex = 6;
                        else navIndex = 1; // Default 1
                    }
                    else if(current === 6) navIndex = 2; 
                }
                moved = true;
            }

            if(moved) { 
                prevNavIndex = current; // Save memory
                updateNavVisuals(); 
                navCooldown = 10; 
            }

// 2. SHOULDER NAV AVEC AUTO-REPEAT (L1 / L2)
            
            // Bouton 6 (L2) : Slot Pr√©c√©dent
            if (gp.buttons[6]?.pressed) {
                l2HoldTimer++;
                if (l2HoldTimer === 1 || (l2HoldTimer > NAV_REPEAT_DELAY && (l2HoldTimer % NAV_REPEAT_RATE === 0))) {
                    let newIdx = activeSlotIndex - 1; 
                    if(newIdx < 0) newIdx = currentData.length - 1; 
                    selectSlot(newIdx);
                }
            } else { l2HoldTimer = 0; }

            // Bouton 4 (L1) : Slot Suivant
            if (gp.buttons[4]?.pressed) {
                l1HoldTimer++;
                if (l1HoldTimer === 1 || (l1HoldTimer > NAV_REPEAT_DELAY && (l1HoldTimer % NAV_REPEAT_RATE === 0))) {
                    let newIdx = activeSlotIndex + 1; 
                    if(newIdx >= currentData.length) newIdx = 0; 
                    selectSlot(newIdx);
                }
            } else { l1HoldTimer = 0; }
            
// R1 / R2 REPEAT LOGIC (MODIFI√â : R2 pour Pr√©c√©dent, R1 pour Suivant)
            
            // Bouton 7 (R2) = Reculer dans la timeline
            if (gp.buttons[7]?.pressed) {
                r1HoldTimer++;
                if (r1HoldTimer === 1 || (r1HoldTimer > NAV_REPEAT_DELAY && (r1HoldTimer % NAV_REPEAT_RATE === 0))) {
                    if(selectedLineIndex > 0) selectLine(selectedLineIndex - 1);
                }
            } else { r1HoldTimer = 0; }

            // Bouton 5 (R1) = Avancer dans la timeline
            if (gp.buttons[5]?.pressed) {
                r2HoldTimer++;
                if (r2HoldTimer === 1 || (r2HoldTimer > NAV_REPEAT_DELAY && (r2HoldTimer % NAV_REPEAT_RATE === 0))) {
                    const tLen = currentData[activeSlotIndex].timeline.length; 
                    if(selectedLineIndex < tLen - 1) selectLine(selectedLineIndex + 1);
                }
            } else { r2HoldTimer = 0; }


            // 3. START BUTTON INTERACTION (ON RELEASE)
            const startBtnKey = Object.keys(btnMap).find(k => btnMap[k] === "Start");
            if (startBtnKey !== undefined) {
                const startPressed = gp.buttons[startBtnKey]?.pressed;
                const startReleased = !startPressed && lastButtons[startBtnKey]; // ON RELEASE
                
                if (startReleased) {
                    if (navIndex === 2) { insertStep(); } 
                    else if (navIndex === 3) { toggleRecording(); } 
                    else if (navIndex === 4) {
                        const chk = document.getElementById('chk-slot-active');
                        chk.checked = !chk.checked; chk.dispatchEvent(new Event('change'));
                    } 
                    else if (navIndex === 6) { } 
                    else {
                        document.getElementById(NAV_IDS[navIndex]).focus();
                    }
                }
            }

            // 4. SELECT BUTTON INTERACTION
            const selectBtnKey = Object.keys(btnMap).find(k => btnMap[k] === "Select");
            if (selectBtnKey !== undefined) {
                const btn = gp.buttons[selectBtnKey];
                if (btn && btn.pressed && !lastButtons[selectBtnKey]) {
                    if (navIndex === 6) { deleteStep(); }
                }
            }
        }

        // --- EDITING ---
        const inputs = ['edit-frames', 'edit-action', 'inp-weight'];
        inputs.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('focus', () => { isInputFocused = true; updateNavVisuals(); el.style.borderColor = "var(--accent-green)"; });
            el.addEventListener('blur', () => { isInputFocused = false; updateNavVisuals(); el.style.borderColor = "#555"; });
        });

        document.getElementById('edit-frames').addEventListener('change', (e) => {
            if (selectedLineIndex !== -1) updateData(selectedLineIndex, e.target.value, null);
        });
        document.getElementById('edit-action').addEventListener('change', (e) => {
            if (selectedLineIndex !== -1) updateData(selectedLineIndex, null, e.target.value);
        });
        document.getElementById('inp-weight').addEventListener('change', (e) => {
            currentData[activeSlotIndex].weight = parseInt(e.target.value) || 1;
        });

        function updateData(idx, frames, action) {
            let line = currentData[activeSlotIndex].timeline[idx];
            let parts = line.split(':');
            let cf = parts[0].replace('f','').trim();
            let ca = parts[1] ? parts[1].trim() : "5";
            if(frames !== null) cf = frames;
            if(action !== null) ca = action;
            currentData[activeSlotIndex].timeline[idx] = `${cf}f : ${ca}`;
            renderTimeline();
            if(action !== null) visualizeAction(ca);
        }

        function insertStep() {
            if(selectedLineIndex === -1) {
                currentData[activeSlotIndex].timeline.push("10f : 5");
                selectedLineIndex = currentData[activeSlotIndex].timeline.length - 1;
            } else {
                currentData[activeSlotIndex].timeline.splice(selectedLineIndex+1, 0, "10f : 5");
                selectedLineIndex++;
            }
            renderTimeline('insert'); updateEditorFields();
        }
        function deleteStep() {
            if(selectedLineIndex !== -1) {
                currentData[activeSlotIndex].timeline.splice(selectedLineIndex, 1);
                if(selectedLineIndex >= currentData[activeSlotIndex].timeline.length) {
                    selectedLineIndex = currentData[activeSlotIndex].timeline.length - 1;
                }
                renderTimeline('delete'); updateEditorFields();
            }
        }

        // --- RECORDING ---
        function toggleRecording() { recordingState.active ? stopRecording() : startRecording(); }
        function startRecording() {
            recordingState.active = true; recordingState.waiting = true; recordingState.lastInput = null;
            const btn = document.getElementById('btn-record-main');
            btn.classList.add('waiting'); btn.textContent = "WAITING INPUT...";
            document.activeElement.blur(); updateNavVisuals();
        }
        function stopRecording() {
            recordingState.active = false; recordingState.waiting = false;
            const btn = document.getElementById('btn-record-main');
            btn.className = "btn-rec"; btn.textContent = "‚è∫ RECORD SLOT";
            updateNavVisuals();
        }

        function handleRecording(input) {
            if (recordingState.waiting) {
                if(input === "5") return;
                recordingState.waiting = false;
                document.getElementById('btn-record-main').classList.add('active');
                document.getElementById('btn-record-main').textContent = "üî¥ RECORDING...";
                
                if (selectedLineIndex === -1) selectedLineIndex = currentData[activeSlotIndex].timeline.length;
                currentData[activeSlotIndex].timeline.splice(selectedLineIndex, 0, `1f : ${input}`);
                recordingState.lastInput = input;
                renderTimeline('insert');
            } else {
                if (input === recordingState.lastInput) {
                    let line = currentData[activeSlotIndex].timeline[selectedLineIndex];
                    let parts = line.split(':');
                    let fr = parseInt(parts[0].replace('f','').trim()) + 1;
                    currentData[activeSlotIndex].timeline[selectedLineIndex] = `${fr}f : ${parts[1]}`;
                    renderTimeline(); // No flash on extend
                } else {
                    selectedLineIndex++;
                    currentData[activeSlotIndex].timeline.splice(selectedLineIndex, 0, `1f : ${input}`);
                    recordingState.lastInput = input;
                    renderTimeline('insert'); // Flash on new input
                }
            }
            updateEditorFields();
        }

        function handleInputMode(gp, rawStr) {
            const el = document.getElementById(document.activeElement.id);
            if(!el) return;

            // Handle Value Increment (Up/Down)
            if(el.id === 'edit-frames' || el.id === 'inp-weight') {
                let y = gp.axes[1];
                if(gp.buttons[12]?.pressed) y = -1; if(gp.buttons[13]?.pressed) y = 1;
                if (navCooldown === 0) {
                    if (y < -0.5) { 
                        el.value = parseInt(el.value) + 1; el.dispatchEvent(new Event('change')); navCooldown = 8;
                    } else if (y > 0.5) { 
                        let val = parseInt(el.value) - 1; if(val < 1) val = 1;
                        el.value = val; el.dispatchEvent(new Event('change')); navCooldown = 8;
                    }
                } else { navCooldown--; }
            }

            // Normal Input handling
            let dir = 5; if (rawStr.match(/^\d/)) dir = parseInt(rawStr.charAt(0));
            let changed = false;

            if (dir !== lastDirection && dir !== 5) {
                if(el.id === 'edit-action') {
                   let cur = el.value; let btns = cur.replace(/^[1-9]\+?/, ""); 
                   el.value = btns ? (dir + "+" + btns) : dir; changed = true;
                }
            }
            lastDirection = dir;

            gp.buttons.forEach((b, i) => {
                const startBtnKey = Object.keys(btnMap).find(k => btnMap[k] === "Start");
                const isStartButton = i.toString() === startBtnKey;
                
                // Pour START : ON RELEASE uniquement
                if (isStartButton) {
                    const startReleased = !b.pressed && lastButtons[i];
                    if (startReleased && startHoldFrames === 0) {
                        el.blur(); 
                        updateNavVisuals();
                    }
                } else {
                    // Pour les autres boutons : ON PRESS
                    if(b.pressed && !lastButtons[i]) {
                        if(btnMap[i]) {
                            const action = btnMap[i];
                            if (action === "Select") {
                                 if(el.id === 'edit-frames' || el.id === 'inp-weight') { el.value = "1"; }
                                 else if(el.id === 'edit-action') { el.value = "5"; }
                                 changed = true;
                            } 
                            else {
                                if(el.id === 'edit-action') {
                                    let cur = el.value; if(cur === "5") cur = "";
                                    let currentBtns = cur.replace(/^[1-9]\+?/, "").split('+').filter(x=>x);
                                let inputsToAdd = MACRO_EXPANSION[action] || [action];
                                inputsToAdd.forEach(inp => { if(!currentBtns.includes(inp)) currentBtns.push(inp); });
                                currentBtns = sortButtons(currentBtns);
                                let newDir = cur.match(/^[1-9]/) ? cur.charAt(0) : "5";
                                let newStr = newDir + (currentBtns.length > 0 ? "+" + currentBtns.join('+') : "");
                                el.value = newStr; changed = true;
                            }
                        }
                    }
                }
            }
            });
            if(changed) el.dispatchEvent(new Event('change'));
        }

        function getGamepadString(gp) {
            let rawL = gp.buttons[14]?.pressed || gp.axes[0] < -0.4;
            let rawR = gp.buttons[15]?.pressed || gp.axes[0] > 0.4;
            let rawU = gp.buttons[12]?.pressed || gp.axes[1] < -0.4;
            let rawD = gp.buttons[13]?.pressed || gp.axes[1] > 0.4;

            let finalL=rawL, finalR=rawR, finalU=rawU, finalD=rawD;

            if (rawL && rawR) {
                if (socdMode === 'NEUTRAL' || socdMode === 'UP_PRIO') { finalL = false; finalR = false; } 
                else if (socdMode === 'LAST_WIN') {
                    if (rawL && !lastInputState.l) lastWinHorz = 'L'; if (rawR && !lastInputState.r) lastWinHorz = 'R';
                    if (lastWinHorz === 'L') finalR = false; else finalL = false;
                }
            } else { if (rawL) lastWinHorz = 'L'; if (rawR) lastWinHorz = 'R'; }

            if (rawU && rawD) {
                if (socdMode === 'NEUTRAL') { finalU = false; finalD = false; } 
                else if (socdMode === 'UP_PRIO') { finalD = false; } 
                else if (socdMode === 'LAST_WIN') {
                    if (rawU && !lastInputState.u) lastWinVert = 'U'; if (rawD && !lastInputState.d) lastWinVert = 'D';
                    if (lastWinVert === 'U') finalD = false; else finalU = false;
                }
            } else { if (rawU) lastWinVert = 'U'; if (rawD) lastWinVert = 'D'; }

            lastInputState = { l: rawL, r: rawR, u: rawU, d: rawD };

            let x=0, y=0; if(finalL) x=-1; if(finalR) x=1; if(finalU) y=-1; if(finalD) y=1;
            let dir = 5;
            if (y === -1) { dir = (x === -1) ? 7 : (x === 1 ? 9 : 8); }
            else if (y === 1) { dir = (x === -1) ? 1 : (x === 1 ? 3 : 2); }
            else { dir = (x === -1) ? 4 : (x === 1 ? 6 : 5); }

            let acts = [];
            gp.buttons.forEach((b, i) => {
                if (i >= 12 && i <= 15) return;
                if (b.pressed && btnMap[i]) { 
                    let val = btnMap[i]; 
                    if(val === "Start" || val === "Select") return; 
                    if (MACRO_EXPANSION[val]) { MACRO_EXPANSION[val].forEach(sub => { if(!acts.includes(sub)) acts.push(sub); }); } 
                    else { if(!acts.includes(val)) acts.push(val); }
                }
            });
            acts = sortButtons(acts);
            let str = (dir !== 5) ? String(dir) : "";
            if (acts.length > 0) { let aStr = acts.join("+"); str = str ? (str + "+" + aStr) : aStr; }
            return str || "5";
        }

        function loop(timestamp) {
            if(!lastFrameTime) lastFrameTime = timestamp;
            const delta = timestamp - lastFrameTime;

            if (delta >= FRAME_INTERVAL) {
                lastFrameTime = timestamp;
                const gamepads = navigator.getGamepads();
                let gp = null; for(let g of gamepads) { if(g) { gp = g; break; } }
                const led = document.getElementById('gp-led');
                const txt = document.getElementById('gp-text');

                if (gp) {
                    led.style.background = "#0f0"; led.style.boxShadow = "0 0 10px #0f0"; txt.textContent = "CONTROLLER CONNECTED (60Hz)";
                    
                    // Trouver le bouton START
                    const startBtnKey = Object.keys(btnMap).find(k => btnMap[k] === "Start");
                    const startPressed = startBtnKey && gp.buttons[startBtnKey]?.pressed;
                    const startReleased = startBtnKey && !startPressed && lastButtons[startBtnKey]; // ON RELEASE
                    
                    // Gestion du menu de configuration
                    if (configMenuOpen) {
                        // Navigation dans le menu
                        handleConfigMenuNavigation(gp);
                        
                        // START ON RELEASE ferme le menu (sauf si c'est le premier release apr√®s ouverture)
                        if (startReleased) {
                            if (ignoreNextStartRelease) {
                                // Ignorer ce release (c'est celui qui a ouvert le menu)
                                ignoreNextStartRelease = false;
                            } else {
                                // Fermer le menu
                                closeConfigModal();
                            }
                        }
                        
                        // Mettre √† jour lastButtons et lastAxes
                        gp.buttons.forEach((b, i) => { lastButtons[i] = b.pressed; });
                        gp.axes.forEach((a, i) => { lastAxes[i] = a; });
                    } else {
                        // MENU FERM√â : Gestion du timer START pour ouvrir le menu (HOLD)
                        if (startPressed) {
                            startHoldFrames++;
                            
                            // Feedback visuel sur le bouton config pendant le hold
                            const progressBar = document.getElementById('config-progress');
                            if (startHoldFrames > 0 && startHoldFrames < START_HOLD_THRESHOLD) {
                                const progress = (startHoldFrames / START_HOLD_THRESHOLD) * 100;
                                progressBar.style.width = progress + '%';
                                progressBar.style.background = 'var(--accent-green)';
                            }
                            
                            // Quand c'est plein, passer en jaune
                            if (startHoldFrames >= START_HOLD_THRESHOLD) {
                                progressBar.style.width = '100%';
                                progressBar.style.background = 'var(--accent-green)';
                                openConfigModal();
                                // Reset la barre apr√®s un court d√©lai
                                setTimeout(() => {
                                    progressBar.style.width = '0%';
                                }, 100);
                                // NE PAS reset startHoldFrames ici ! On va le faire au release
                            }
                        } else {
                            // START rel√¢ch√©
                            if (startHoldFrames > 0) {
                                // On √©tait en train de hold, on reset
                                startHoldFrames = 0;
                                const progressBar = document.getElementById('config-progress');
                                progressBar.style.width = '0%';
                                txt.textContent = "CONTROLLER CONNECTED (60Hz)";
                                txt.style.color = "";
                            }
                        }
                        
                        // Logique normale du jeu
                        const raw = getGamepadString(gp);

                        if (remapState.active) {
                            let pressed = -1; gp.buttons.forEach((b, i) => { if(b.pressed) pressed = i; });
                            if (pressed !== -1) {
                                Object.keys(btnMap).forEach(k => { if(btnMap[k] === remapState.action) delete btnMap[k]; });
                                btnMap[pressed] = remapState.action; saveConfig();
                                remapState = { active: false, action: null }; setTimeout(renderConfigList, 200);
                            }
                        } else {
                            visualizeAction(raw);
                            if (recordingState.active) {
                                // START ON RELEASE arr√™te l'enregistrement (seulement si pas en train de hold pour le menu)
                                if (startReleased && startHoldFrames === 0) {
                                    stopRecording();
                                } else {
                                    handleRecording(raw);
                                }
                            } else if (isInputFocused) {
                                handleInputMode(gp, raw);
                            } else {
                                // Seulement si on n'est PAS en train de hold START
                                if (startHoldFrames === 0) {
                                    handleNavigation(gp);
                                }
                            }
                            gp.buttons.forEach((b, i) => { lastButtons[i] = b.pressed; });
                            gp.axes.forEach((a, i) => { lastAxes[i] = a; });
                        }
                    }
                } else {
                    led.style.background = "#333"; led.style.boxShadow = "none"; txt.textContent = "NO CONTROLLER";
                    txt.style.color = "";
                    startHoldFrames = 0; // Reset le timer si pas de manette
                }
            }
            requestAnimationFrame(loop);
        }

        function visualizeAction(actionStr) {
            document.querySelectorAll('.arrow-shape').forEach(p => p.classList.remove('arrow-active'));
            document.getElementById('arrow-5').classList.remove('active');
            document.querySelectorAll('.btn-bg').forEach(b => b.classList.remove('btn-active'));
            if(!actionStr) { document.getElementById('arrow-5').classList.add('active'); return; }
            const parts = actionStr.split('+');
            let dir = 5; parts.forEach(p => { if(p.length===1 && !isNaN(p)) dir = parseInt(p); });
            if(dir === 5) { document.getElementById('arrow-5').classList.add('active'); } 
            else { let el = document.getElementById(`arrow-${dir}`); if(el) el.classList.add('arrow-active'); }
            
            let buttonsToLight = [];
            parts.forEach(p => { if (MACRO_EXPANSION[p]) buttonsToLight.push(...MACRO_EXPANSION[p]); else buttonsToLight.push(p); });
            [...new Set(buttonsToLight)].forEach(b => { let el = document.getElementById(`vis-btn-${b.toLowerCase()}`); if(el) el.classList.add('btn-active'); });
        }

        function setupEventListeners() {
            document.getElementById('fileInput').addEventListener('change', (e) => {
                const f = e.target.files[0]; if(!f) return;
                currentFileName = f.name; document.getElementById('current-file-name').textContent = f.name;
                const r = new FileReader();
                r.onload = (ev) => { try { currentData = JSON.parse(ev.target.result); activeSlotIndex = 0; renderAll(); } catch(x){alert("Invalid JSON");} };
                r.readAsText(f); e.target.value = '';
            });
            
            // Fermer le modal avec ECHAP
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && configMenuOpen) {
                    closeConfigModal();
                }
            });
        }
        function saveJson() {
            const b = new Blob([JSON.stringify(currentData, null, 4)], {type:"application/json"});
            const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = currentFileName;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
        init();
    </script>
</body>
</html>